package tsdemux

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/tony-507/analyzers/src/plugins/common"
	"github.com/tony-507/analyzers/src/tttKernel"
)

type dummyCallback struct {}

func (dc *dummyCallback) outputReady() {}

func (dc *dummyCallback) getOutDir() string {
	return "output"
}

func TestDemuxDeliverUnit(t *testing.T) {
	m_pMux := tsDemuxerPlugin{name: "dummy"}
	m_parameter := "{\"Mode\": \"_DEMUX_DUMMY\"}"
	m_pMux.SetParameter(m_parameter)

	m_pMux.SetCallback(func(s string, reqType tttKernel.WORKER_REQUEST, obj interface{}) {
		expected := tttKernel.MakeReqUnit("dummy", tttKernel.FETCH_REQUEST)
		assert.Equal(t, expected, obj, "Unit not equal")
	})

	for i := 0; i < 2; i++ {
		buf := tttKernel.MakeSimpleBuf([]byte{byte(i)})
		dummy := common.NewMediaUnit(buf, common.UNKNOWN_UNIT)
		m_pMux.DeliverUnit(dummy, "")
	}
}

func TestDemuxPipeProcessing(t *testing.T) {
	dummyPAT := []byte{0x47, 0x40, 0x00, 0x14, 0x00, 0x00, 0xB0, 0x0D, 0x11, 0x11, 0xC1,
		0x00, 0x00, 0x00, 0x0A, 0xE1, 0x02, 0xAA, 0x4A, 0xE2, 0xD2}

	control := getControl()
	dc := dummyCallback{}
	impl := getDemuxPipe(&dc, control, "Dummy")

	impl.processUnit(dummyPAT, 0)

	programMap := make(map[int]int, 0)
	programMap[10] = 258

	assert.Equal(t, programMap, impl.programRecords, "PAT not match")

	dummyPMT := []byte{0x47, 0x41, 0x02, 0x14, 0x00, 0x02, 0xb0, 0x1d, 0x00, 0x0a, 0xc1,
		0x00, 0x00, 0xe0, 0x20, 0xf0, 0x00, 0x02, 0xe0, 0x20,
		0xf0, 0x00, 0x04, 0xe0, 0x21, 0xf0, 0x06, 0x0a, 0x04,
		0x65, 0x6e, 0x67, 0x00, 0x75, 0xff, 0x59, 0x3a}

	impl.processUnit(dummyPMT, 0)

	streamRecords := make(map[int]int, 0)
	streamRecords[32] = 2
	streamRecords[33] = 4

	assert.Equal(t, streamRecords, impl.streamRecords, "PMT not match")

	unknownPkt := []byte{0x47, 0x40, 0x51, 0x11, 0xff}

	impl.processUnit(unknownPkt, 0)

	pCnt := 0
	for _, cnt := range impl.control.pktCntMap {
		pCnt += cnt
	}
	assert.Equal(t, 2, pCnt, "Process count not match")
}

func TestMultipleTsPacketPsi(t *testing.T) {
	pmt1 := []byte{0x47, 0x41, 0xE0, 0x1F, 0x00, 0x02, 0xB0, 0xB9, 0x00, 0x0A, 0xC1, 0x00, 0x00, 0xE0, 0x20, 0xF0,
		0x06, 0x05, 0x04, 0x43, 0x55, 0x45, 0x49, 0x1B, 0xE0, 0x20, 0xF0, 0x16, 0x41, 0x00, 0x43, 0x00,
		0x41, 0x00, 0x41, 0x00, 0x41, 0x00, 0x41, 0x00, 0x43, 0x00, 0x12, 0x00, 0x45, 0x00, 0x66, 0x00,
		0x41, 0x00, 0x0F, 0xE0, 0x21, 0xF0, 0x28, 0xDD, 0x09, 0x48, 0x41, 0x52, 0x01, 0x01, 0x00, 0x01,
		0x77, 0x00, 0x0A, 0x04, 0x65, 0x6E, 0x67, 0x00, 0x41, 0x00, 0x43, 0x00, 0x41, 0x00, 0x43, 0x00,
		0x41, 0x00, 0x43, 0x00, 0x41, 0x00, 0x79, 0x00, 0x41, 0x00, 0x43, 0x00, 0x1C, 0x01, 0x58, 0x86,
		0xE0, 0x23, 0xF0, 0x06, 0x41, 0x00, 0x41, 0x00, 0x41, 0x00, 0x86, 0xE0, 0x24, 0xF0, 0x06, 0x41,
		0x00, 0x41, 0x00, 0x41, 0x00, 0x86, 0xE0, 0x25, 0xF0, 0x06, 0x41, 0x00, 0x41, 0x00, 0x41, 0x00,
		0x86, 0xE0, 0x26, 0xF0, 0x08, 0x41, 0x00, 0x41, 0x00, 0x41, 0x00, 0x41, 0x00, 0x86, 0xE0, 0x27,
		0xF0, 0x06, 0x41, 0x00, 0x41, 0x00, 0x41, 0x00, 0x86, 0xE0, 0x28, 0xF0, 0x06, 0x41, 0x00, 0x41,
		0x00, 0x41, 0x00, 0x86, 0xE0, 0x29, 0xF0, 0x06, 0x41, 0x00, 0x41, 0x00, 0x41, 0x00, 0x86, 0xE0,
		0x30, 0xF0, 0x0A, 0x41, 0x00, 0x41, 0x00, 0x41, 0x00, 0x41, 0x00, 0x41}
	pmt2 := []byte{0x47, 0x01, 0xE0, 0x10, 0x00, 0x2E, 0x06, 0x44, 0x2E}

	control := getControl()
	dc := dummyCallback{}
	impl := getDemuxPipe(&dc, control, "Dummy")

	impl.programRecords[10] = 480
	impl.processUnit(pmt1, 0)

	assert.Equal(t, true, impl.dataStructs[480] != nil, "non-terminating PMT should be stored")

	impl.processUnit(pmt2, 1)

	assert.Equal(t, true, impl.dataStructs[480] == nil, "PMT should be null now")

	expected := make(map[int]int, 0)
	expected[32] = 27
	expected[33] = 15
	expected[35] = 134
	expected[36] = 134
	expected[37] = 134
	expected[38] = 134
	expected[39] = 134
	expected[40] = 134
	expected[41] = 134
	expected[48] = 134
	assert.Equal(t, expected, impl.streamRecords, "PMT stream mapping not match")
}

func TestPesParsedOnceReady(t *testing.T) {
	pkt1 := []byte{0x47, 0x40, 0x20, 0x33, 0x07, 0x50, 0x00, 0x04, 0xCE, 0xCD, 0x7E, 0xF3, 0x00, 0x00, 0x01, 0xEA,
		0x00, 0xAF, 0x8F, 0xC0, 0x0A, 0x31, 0x00, 0x2B, 0x85, 0xFB, 0x11, 0x00, 0x2B, 0x31, 0x9B, 0x00,
		0x00, 0x01, 0xB3, 0x2C, 0x02, 0x40, 0x23, 0x06, 0x43, 0x63, 0x41, 0x10, 0x11, 0x11, 0x12, 0x12,
		0x12, 0x13, 0x13, 0x13, 0x13, 0x14, 0x14, 0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
		0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x18,
		0x18, 0x18, 0x19, 0x18, 0x18, 0x18, 0x19, 0x1A, 0x1A, 0x1A, 0x1A, 0x19, 0x1B, 0x1B, 0x1B, 0x1B,
		0x1B, 0x1C, 0x1C, 0x1C, 0x1C, 0x1E, 0x1E, 0x1E, 0x1F, 0x1F, 0x21, 0x00, 0x00, 0x01, 0xB5, 0x14,
		0x82, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xB8, 0x2D, 0xE8, 0x00, 0xC0, 0x00, 0x00, 0x01,
		0x00, 0x00, 0x8F, 0xFF, 0xF8, 0x00, 0x00, 0x01, 0xB5, 0x8F, 0xFF, 0xFB, 0xDC, 0x00, 0x00, 0x00,
		0x01, 0x01, 0x42, 0xA7, 0xF8, 0x7E, 0xD1, 0xA3, 0x46, 0x18, 0x6E, 0x34, 0x68, 0xD1, 0x86, 0x1B,
		0x8D, 0x1A, 0x34, 0x61, 0x86, 0xE3, 0x46, 0x8D, 0x18, 0x61, 0xB8, 0xD1, 0xA3, 0x46, 0x18, 0x6E,
		0x34, 0x68, 0xD1, 0x86, 0x1B, 0x8D, 0x1A, 0x34, 0x61, 0x86, 0xE3, 0x46}
	pkt2 := []byte{0x47, 0x00, 0x20, 0x14, 0x8D, 0x18, 0x61, 0xB8, 0xD1}

	control := getControl()
	dc := dummyCallback{}
	r := tttKernel.CreateResourceLoader()
	control.setResource(&r)
	impl := getDemuxPipe(&dc, control, "Dummy")

	impl.programRecords[10] = 480
	impl.streamRecords[32] = 2

	impl.processUnit(pkt1, 1)
	assert.Equal(t, true, impl.dataStructs[32] != nil, "PES packet should be stored")

	impl.processUnit(pkt2, 2)
	assert.Equal(t, true, impl.dataStructs[32] == nil, "PES packet should be parsed")
}
