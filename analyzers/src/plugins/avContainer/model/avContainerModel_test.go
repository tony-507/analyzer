package model

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

type dummyManagerStruct struct {
	programRecords     map[int]int
	streamRecords      map[int]int
	patVersion         int
	pmtVersion         int
	psiJsons           map[int][]byte
	scte35SplicePTS    []int
	receivedSpliceNull bool
}

func (m *dummyManagerStruct) AddStream(version int, progNum int, streamPid int, streamType int) {
	m.streamRecords[streamPid] = streamType
}

func (m *dummyManagerStruct) AddProgram(version int, progNum int, pid int) {
	m.programRecords[progNum] = pid
	m.patVersion = version
}

func (m *dummyManagerStruct) GetPATVersion() int {
	return m.patVersion
}

func (m *dummyManagerStruct) GetPmtVersion(progNum int) int {
	return m.pmtVersion
}

func (m *dummyManagerStruct) GetPmtPidByProgNum(progNum int) int {
	return m.programRecords[progNum]
}

func (m *dummyManagerStruct) PsiUpdateFinished(pid int, jsonBytes []byte) {
	m.psiJsons[pid] = jsonBytes
}

func (m *dummyManagerStruct) SpliceEventReceived(dpiPid int, spliceCmdTypeStr string, splicePTS []int, pktCnt int) {
	if spliceCmdTypeStr == "splice_null" {
		m.receivedSpliceNull = true
	} else {
		m.scte35SplicePTS = append(m.scte35SplicePTS, splicePTS...)
	}
}

func dummyManager() *dummyManagerStruct {
	rv := &dummyManagerStruct{}
	rv.programRecords = make(map[int]int, 0)
	rv.streamRecords = make(map[int]int, 0)
	rv.patVersion = -1
	rv.pmtVersion = -1
	rv.psiJsons = make(map[int][]byte, 0)
	rv.scte35SplicePTS = make([]int, 0)
	rv.receivedSpliceNull = false

	return rv
}

func TestReadPAT(t *testing.T) {
	dummyPAT := []byte{0x00, 0x00, 0xB0, 0x0D, 0x11, 0x11, 0xC1,
		0x00, 0x00, 0x00, 0x0A, 0xE1, 0x02, 0xAA, 0x4A, 0xE2, 0xD2}
	manager := dummyManager()

	table, err := PsiTable(manager, 0, 0, dummyPAT)
	if err != nil {
		panic(err)
	}
	parseErr := table.ParsePayload()
	if parseErr != nil {
		panic(parseErr)
	}
	assert.Equal(t, true, table.Ready(), "PAT should be ready for parsing")
	assert.Equal(t, []byte{0x7b, 0xa, 0x9, 0x9, 0x22, 0x50, 0x6b, 0x74, 0x43,
		0x6e, 0x74, 0x22, 0x3a, 0x20, 0x30, 0x2c, 0xa, 0x9, 0x9, 0x22, 0x56, 0x65,
		0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x20, 0x30, 0x2c, 0xa, 0x9, 0x9,
		0x22, 0x50, 0x72, 0x6f, 0x67, 0x72, 0x61, 0x6d, 0x4d, 0x61, 0x70, 0x22, 0x3a,
		0x20, 0x7b, 0xa, 0x9, 0x9, 0x9, 0x22, 0x31, 0x30, 0x22, 0x3a, 0x20, 0x32, 0x35,
		0x38, 0xa, 0x9, 0x9, 0x7d, 0x2c, 0xa, 0x9, 0x9, 0x22, 0x43, 0x72, 0x63, 0x33,
		0x32, 0x22, 0x3a, 0x20, 0x31, 0x30, 0xa, 0x9, 0x7d},
		manager.psiJsons[0], "PAT content not match")
}

func TestReadPMT(t *testing.T) {
	dummyPMT := []byte{0x00, 0x02, 0xb0, 0x1d, 0x00, 0x0a, 0xc1,
		0x00, 0x00, 0xe0, 0x20, 0xf0, 0x00, 0x02, 0xe0, 0x20,
		0xf0, 0x00, 0x04, 0xe0, 0x21, 0xf0, 0x06, 0x0a, 0x04,
		0x65, 0x6e, 0x67, 0x00, 0x75, 0xff, 0x59, 0x3a}
	manager := dummyManager()
	manager.programRecords[10] = 258

	table, err := PsiTable(manager, 0, 258, dummyPMT)
	if err != nil {
		panic(err)
	}
	assert.Equal(t, true, table.Ready(), "PMT should be ready for parsing")

	parseErr := table.ParsePayload()
	if parseErr != nil {
		panic(parseErr)
	}

	assert.Equal(t, 2, manager.streamRecords[32], "pid 32 should have type 2")
	assert.Equal(t, 4, manager.streamRecords[33], "pid 33 should have type 4")
	assert.Equal(t, []byte{0x7b, 0xa, 0x9, 0x9, 0x22, 0x50, 0x6b, 0x74, 0x43, 0x6e,
		0x74, 0x22, 0x3a, 0x20, 0x30, 0x2c, 0xa, 0x9, 0x9, 0x22, 0x56, 0x65, 0x72,
		0x73, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x20, 0x30, 0x2c, 0xa, 0x9, 0x9, 0x22,
		0x50, 0x72, 0x6f, 0x67, 0x44, 0x65, 0x73, 0x63, 0x22, 0x3a, 0x20, 0x5b, 0x5d,
		0x2c, 0xa, 0x9, 0x9, 0x22, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73, 0x22,
		0x3a, 0x20, 0x5b, 0xa, 0x9, 0x9, 0x9, 0x7b, 0xa, 0x9, 0x9, 0x9, 0x9, 0x22,
		0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x50, 0x69, 0x64, 0x22, 0x3a, 0x20, 0x33,
		0x32, 0x2c, 0xa, 0x9, 0x9, 0x9, 0x9, 0x22, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d,
		0x54, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x20, 0x32, 0x2c, 0xa, 0x9, 0x9, 0x9, 0x9,
		0x22, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x44, 0x65, 0x73, 0x63, 0x22, 0x3a,
		0x20, 0x5b, 0x5d, 0xa, 0x9, 0x9, 0x9, 0x7d, 0x2c, 0xa, 0x9, 0x9, 0x9, 0x7b, 0xa,
		0x9, 0x9, 0x9, 0x9, 0x22, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x50, 0x69, 0x64,
		0x22, 0x3a, 0x20, 0x33, 0x33, 0x2c, 0xa, 0x9, 0x9, 0x9, 0x9, 0x22, 0x53, 0x74,
		0x72, 0x65, 0x61, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x20, 0x34, 0x2c,
		0xa, 0x9, 0x9, 0x9, 0x9, 0x22, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x44, 0x65,
		0x73, 0x63, 0x22, 0x3a, 0x20, 0x5b, 0xa, 0x9, 0x9, 0x9, 0x9, 0x9, 0x7b, 0xa, 0x9,
		0x9, 0x9, 0x9, 0x9, 0x9, 0x22, 0x54, 0x61, 0x67, 0x22, 0x3a, 0x20, 0x31, 0x30,
		0x2c, 0xa, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x22, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e,
		0x74, 0x22, 0x3a, 0x20, 0x22, 0x36, 0x35, 0x20, 0x36, 0x65, 0x20, 0x36, 0x37, 0x20,
		0x30, 0x30, 0x22, 0xa, 0x9, 0x9, 0x9, 0x9, 0x9, 0x7d, 0xa, 0x9, 0x9, 0x9, 0x9, 0x5d,
		0xa, 0x9, 0x9, 0x9, 0x7d, 0xa, 0x9, 0x9, 0x5d, 0x2c, 0xa, 0x9, 0x9, 0x22, 0x43, 0x72,
		0x63, 0x33, 0x32, 0x22, 0x3a, 0x20, 0x31, 0x39, 0x37, 0x39, 0x36, 0x36, 0x38, 0x37,
		0x39, 0x34, 0xa, 0x9, 0x7d}, manager.psiJsons[258], "PMT content not match")
}

func TestAdaptationFieldIO(t *testing.T) {
	caseName := []string{
		"EmptyAdaptationField",
		"AdapationFieldWithPCR",
		"AdapationFieldWithEverything",
	}
	byteSpecs := [][]byte{
		{0x00},
		{0x07, 0x50, 0x00, 0x04, 0xce, 0xcd, 0x7e, 0xf3}, // With PCR
		{0x14, 0x5e, 0x00, 0x04, 0xce, 0xcd, 0x7e, 0xf3, 0x00, 0x04, 0xce, 0xcd, 0x7e, 0xf3, 0x01, 0x03, 0x45, 0x4e, 0x47, 0xff, 0xff}, // With everything
	}
	structSpecs := []AdaptationField{
		{AfLen: 0},
		{AfLen: 7, DisCnt_cnt: 0, RandomAccess: 1, EsIdr: 0, Pcr: 189051243, Opcr: -1, Splice_point: -1, Private_data: "", StuffSize: 0},
		{AfLen: 20, DisCnt_cnt: 0, RandomAccess: 1, EsIdr: 0, Pcr: 189051243, Opcr: 189051243, Splice_point: 1, Private_data: "ENG", StuffSize: 2},
	}

	for idx := range byteSpecs {
		t.Run(caseName[idx], func(t *testing.T) {
			parsed := ParseAdaptationField(byteSpecs[idx])
			assert.Equal(t, structSpecs[idx], parsed, "Adaptation field struct not match")

			buf := structSpecs[idx].Serialize()
			assert.Equal(t, byteSpecs[idx], buf, "Adaptation field bytes not match")
		})
	}
}

func TestPesHeaderIO(t *testing.T) {
	caseName := []string{
		"PesHeaderWithNoTimestamp",
		"PesHeaderWithEqualTimestamp",
		"PesHeaderWithDiffTimestamp",
		"PesHeaderWithZeroLength",
	}
	byteSpecs := [][]byte{
		{0x00, 0x00, 0x01, 0xea, 0x17, 0xb2, 0x8f, 0x00, 0x00},
		{0x00, 0x00, 0x01, 0xea, 0x17, 0xb2, 0x8f, 0x80, 0x05, 0x21, 0x00, 0x2b, 0x4d, 0xbb},
		{0x00, 0x00, 0x01, 0xea, 0x7d, 0xb2, 0x8f, 0xc0, 0x0a, 0x31, 0x00, 0x2b, 0x85, 0xfb, 0x11, 0x00, 0x2b, 0x31, 0x9b},
		{0x00, 0x00, 0x01, 0xea, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05},
	}
	structSpecs := []PESHeader{
		CreatePESHeader(234, 6063, CreateOptionalPESHeader(3, -1, -1)),
		CreatePESHeader(234, 6058, CreateOptionalPESHeader(8, 698077, 698077)),
		CreatePESHeader(234, 32165, CreateOptionalPESHeader(13, 705277, 694477)),
		CreatePESHeader(234, 5, CreateOptionalPESHeader(3, -1, -1)),
	}

	for idx := range byteSpecs {
		t.Run(caseName[idx], func(t *testing.T) {
			parsed, _, err := ParsePESHeader(byteSpecs[idx])
			if err != nil {
				panic(err)
			}

			assert.Equal(t, structSpecs[idx], parsed, "PES header not match")
		})
	}
}

func TestSCTE35IO(t *testing.T) {
	caseName := []string{
		"SpliceNull",
		"SpliceInsert",
	}
	byteSpecs := [][]byte{
		{0x00, 0xfc, 0x30, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00}, // Splice null
		{0x00, 0xfc, 0x30, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0xff, 0xf0, 0x14, 0x05, 0x00, 0x00, 0x00, 0x02, 0x7f,
			0xef, 0xfe, 0x00, 0x2e, 0xb0, 0x30, 0xfe, 0x00, 0x14, 0x99,
			0x70, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0xbb, 0x9e, 0x64, 0x39}, // Splice insert
	}
	manager := dummyManager()

	for idx := range byteSpecs {
		t.Run(caseName[idx], func(t *testing.T) {
			table, err := PsiTable(manager, 0, 35, byteSpecs[idx])
			if err != nil {
				panic(err)
			}
			parseErr := table.ParsePayload()
			if parseErr != nil {
				panic(parseErr)
			}

			assert.Equal(t, true, table.Ready(), "Table should be ready for parsing")

			switch idx {
			case 0:
				assert.Equal(t, true, manager.receivedSpliceNull, "Splice null not received")
			case 1:
				assert.Equal(t, []int{3059760}, manager.scte35SplicePTS, "SCTE-35 splice PTS list not match")
			}
		})
	}
}

func TestTsHeaderIO(t *testing.T) {
	headerBytes := []byte{0x47, 0x03, 0x8f, 0x1f}
	rawTsPacket := append(headerBytes, make([]byte, 184)...)

	pkt, err := TsPacket(rawTsPacket)
	if err != nil {
		panic(err)
	}

	tei, fieldErr := pkt.GetField("tei")
	if fieldErr != nil {
		panic(fieldErr)
	}
	assert.Equal(t, 0, tei, "tei not match")

	pusi, fieldErr := pkt.GetField("pusi")
	if fieldErr != nil {
		panic(fieldErr)
	}
	assert.Equal(t, 0, pusi, "pusi not match")

	priority, fieldErr := pkt.GetField("priority")
	if fieldErr != nil {
		panic(fieldErr)
	}
	assert.Equal(t, 0, priority, "priority not match")

	pid, fieldErr := pkt.GetField("pid")
	if fieldErr != nil {
		panic(fieldErr)
	}
	assert.Equal(t, 911, pid, "pid not match")

	tsc, fieldErr := pkt.GetField("tsc")
	if fieldErr != nil {
		panic(fieldErr)
	}
	assert.Equal(t, 0, tsc, "tsc not match")

	afc, fieldErr := pkt.GetField("afc")
	if fieldErr != nil {
		panic(fieldErr)
	}
	assert.Equal(t, 1, afc, "afc not match")

	cc, fieldErr := pkt.GetField("cc")
	if fieldErr != nil {
		panic(fieldErr)
	}
	assert.Equal(t, 15, cc, "cc not match")

	// headerStruct := TsHeader{Tei: false, Pusi: false, Priority: false, Pid: 911, Tsc: 0, Afc: 1, Cc: 15}
}
