package model

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/tony-507/analyzers/src/common"
)

type dummyManagerStruct struct {
	programRecords     map[int]int
	streamRecords      map[int]int
	patVersion         int
	pmtVersion         int
	psiJsons           map[int][]byte
	scte35SplicePTS    []int
	receivedSpliceNull bool
}

func (m *dummyManagerStruct) AddStream(version int, progNum int, streamPid int, streamType int) {
	m.streamRecords[streamPid] = streamType
}

func (m *dummyManagerStruct) AddProgram(version int, progNum int, pid int) {
	m.programRecords[progNum] = pid
	m.patVersion = version
}

func (m *dummyManagerStruct) GetPATVersion() int {
	return m.patVersion
}

func (m *dummyManagerStruct) GetPmtVersion(progNum int) int {
	return m.pmtVersion
}

func (m *dummyManagerStruct) GetPmtPidByProgNum(progNum int) int {
	return m.programRecords[progNum]
}

func (m *dummyManagerStruct) PsiUpdateFinished(pid int, version int, jsonBytes []byte) {
	m.psiJsons[pid] = jsonBytes
}

func (m *dummyManagerStruct) SpliceEventReceived(dpiPid int, spliceCmdTypeStr string, splicePTS []int) {
	if spliceCmdTypeStr == "splice_null" {
		m.receivedSpliceNull = true
	} else {
		m.scte35SplicePTS = append(m.scte35SplicePTS, splicePTS...)
	}
}

func dummyManager() *dummyManagerStruct {
	rv := &dummyManagerStruct{}
	rv.programRecords = make(map[int]int, 0)
	rv.streamRecords = make(map[int]int, 0)
	rv.patVersion = -1
	rv.pmtVersion = -1
	rv.psiJsons = make(map[int][]byte, 0)
	rv.scte35SplicePTS = make([]int, 0)
	rv.receivedSpliceNull = false

	return rv
}

type dummyPesCallbackStruct struct {
	outputQueue []common.CmBuf
}

func (p *dummyPesCallbackStruct) PesPacketReady(buf common.CmBuf, pid int) {
	p.outputQueue = append(p.outputQueue, buf)
}

func dummyPesCallback() pesHandle {
	rv := &dummyPesCallbackStruct{}
	rv.outputQueue = make([]common.CmBuf, 0)
	return rv
}

func TestReadPAT(t *testing.T) {
	dummyPAT := []byte{0x00, 0x00, 0xB0, 0x0D, 0x11, 0x11, 0xC1,
		0x00, 0x00, 0x00, 0x0A, 0xE1, 0x02, 0xAA, 0x4A, 0xE2, 0xD2}
	manager := dummyManager()

	table, err := PsiTable(manager, 0, 0, dummyPAT)
	if err != nil {
		panic(err)
	}
	parseErr := table.Process()
	if parseErr != nil {
		panic(parseErr)
	}
	assert.Equal(t, true, table.Ready(), "PAT should be ready for parsing")
	assert.Equal(t, []byte{0x7b, 0xa, 0x9, 0x22, 0x50, 0x6b, 0x74, 0x43, 0x6e, 0x74,
		0x22, 0x3a, 0x20, 0x30, 0x2c, 0xa, 0x9, 0x22, 0x56, 0x65, 0x72, 0x73, 0x69,
		0x6f, 0x6e, 0x22, 0x3a, 0x20, 0x30, 0x2c, 0xa, 0x9, 0x22, 0x50, 0x72, 0x6f,
		0x67, 0x72, 0x61, 0x6d, 0x4d, 0x61, 0x70, 0x22, 0x3a, 0x20, 0x7b, 0xa, 0x9,
		0x9, 0x22, 0x31, 0x30, 0x22, 0x3a, 0x20, 0x32, 0x35, 0x38, 0xa, 0x9, 0x7d,
		0x2c, 0xa, 0x9, 0x22, 0x43, 0x72, 0x63, 0x33, 0x32, 0x22, 0x3a, 0x20, 0x31,
		0x30, 0xa, 0x7d},
		manager.psiJsons[0], "PAT content not match")
}

func TestReadPMT(t *testing.T) {
	dummyPMT := []byte{0x00, 0x02, 0xb0, 0x1d, 0x00, 0x0a, 0xc1,
		0x00, 0x00, 0xe0, 0x20, 0xf0, 0x00, 0x02, 0xe0, 0x20,
		0xf0, 0x00, 0x04, 0xe0, 0x21, 0xf0, 0x06, 0x0a, 0x04,
		0x65, 0x6e, 0x67, 0x00, 0x75, 0xff, 0x59, 0x3a}
	manager := dummyManager()
	manager.programRecords[10] = 258

	table, err := PsiTable(manager, 0, 258, dummyPMT)
	if err != nil {
		panic(err)
	}
	assert.Equal(t, true, table.Ready(), "PMT should be ready for parsing")

	parseErr := table.Process()
	if parseErr != nil {
		panic(parseErr)
	}

	assert.Equal(t, 2, manager.streamRecords[32], "pid 32 should have type 2")
	assert.Equal(t, 4, manager.streamRecords[33], "pid 33 should have type 4")
	assert.Equal(t, []byte{0x7b, 0xa, 0x9, 0x22, 0x50, 0x6b, 0x74, 0x43, 0x6e, 0x74, 0x22, 0x3a,
		0x20, 0x30, 0x2c, 0xa, 0x9, 0x22, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x3a,
		0x20, 0x30, 0x2c, 0xa, 0x9, 0x22, 0x50, 0x72, 0x6f, 0x67, 0x44, 0x65, 0x73, 0x63, 0x22,
		0x3a, 0x20, 0x5b, 0x5d, 0x2c, 0xa, 0x9, 0x22, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73,
		0x22, 0x3a, 0x20, 0x5b, 0xa, 0x9, 0x9, 0x7b, 0xa, 0x9, 0x9, 0x9, 0x22, 0x53, 0x74, 0x72,
		0x65, 0x61, 0x6d, 0x50, 0x69, 0x64, 0x22, 0x3a, 0x20, 0x33, 0x32, 0x2c, 0xa, 0x9, 0x9,
		0x9, 0x22, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x20,
		0x32, 0x2c, 0xa, 0x9, 0x9, 0x9, 0x22, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x44, 0x65, 0x73,
		0x63, 0x22, 0x3a, 0x20, 0x5b, 0x5d, 0xa, 0x9, 0x9, 0x7d, 0x2c, 0xa, 0x9, 0x9, 0x7b, 0xa, 0x9,
		0x9, 0x9, 0x22, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x50, 0x69, 0x64, 0x22, 0x3a, 0x20, 0x33,
		0x33, 0x2c, 0xa, 0x9, 0x9, 0x9, 0x22, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x54, 0x79, 0x70,
		0x65, 0x22, 0x3a, 0x20, 0x34, 0x2c, 0xa, 0x9, 0x9, 0x9, 0x22, 0x53, 0x74, 0x72, 0x65, 0x61,
		0x6d, 0x44, 0x65, 0x73, 0x63, 0x22, 0x3a, 0x20, 0x5b, 0xa, 0x9, 0x9, 0x9, 0x9, 0x7b, 0xa,
		0x9, 0x9, 0x9, 0x9, 0x9, 0x22, 0x54, 0x61, 0x67, 0x22, 0x3a, 0x20, 0x31, 0x30, 0x2c, 0xa,
		0x9, 0x9, 0x9, 0x9, 0x9, 0x22, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x22, 0x3a, 0x20,
		0x22, 0x36, 0x35, 0x20, 0x36, 0x65, 0x20, 0x36, 0x37, 0x20, 0x30, 0x30, 0x22, 0xa, 0x9, 0x9,
		0x9, 0x9, 0x7d, 0xa, 0x9, 0x9, 0x9, 0x5d, 0xa, 0x9, 0x9, 0x7d, 0xa, 0x9, 0x5d, 0x2c, 0xa,
		0x9, 0x22, 0x43, 0x72, 0x63, 0x33, 0x32, 0x22, 0x3a, 0x20, 0x31, 0x39, 0x37, 0x39, 0x36,
		0x36, 0x38, 0x37, 0x39, 0x34, 0xa, 0x7d}, manager.psiJsons[258], "PMT content not match")
}

func TestAdaptationFieldIO(t *testing.T) {
	caseName := []string{
		"EmptyAdaptationField",
		"AdapationFieldWithPCR",
		"AdapationFieldWithEverything",
	}
	byteSpecs := [][]byte{
		{0x00},
		{0x07, 0x50, 0x00, 0x04, 0xce, 0xcd, 0x7e, 0xf3}, // With PCR
		{0x14, 0x5e, 0x00, 0x04, 0xce, 0xcd, 0x7e, 0xf3, 0x00, 0x04, 0xce, 0xcd, 0x7e, 0xf3, 0x01, 0x03, 0x45, 0x4e, 0x47, 0xff, 0xff}, // With everything
	}
	afSize := []int{1, 8, 21}
	resSpec := make(map[string][]int, 0)
	resSpec["discontinuityIdr"] = []int{0, 0}
	resSpec["randomAccessIdr"] = []int{1, 1}
	resSpec["esPriorityIdr"] = []int{0, 0}
	resSpec["pcr"] = []int{189051243, 189051243}
	resSpec["opcr"] = []int{-1, 189051243}
	resSpec["spliceCountdown"] = []int{-1, 1}

	for idx := range byteSpecs {
		t.Run(caseName[idx], func(t *testing.T) {
			pkt := &tsPacketStruct{hasAdaptationField: false}
			l, err := pkt.readAdaptationField(byteSpecs[idx])
			if err != nil {
				panic(err)
			}
			assert.Equal(t, afSize[idx], l, "Adaptation field size not equal")

			if idx == 0 {
				return
			}

			for k, v := range resSpec {
				rv, err := pkt.GetValueFromAdaptationField(k)
				if err != nil {
					panic(err)
				}
				assert.Equal(t, v[idx-1], rv, fmt.Sprintf("%s not equal", k))
			}
		})
	}
}

func TestPesPacketReady(t *testing.T) {
	pkt1 := []byte{0x00, 0x00, 0x01, 0xea, 0x00, 0x0a, 0x8f, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04}
	pkt2 := []byte{0x05, 0x06, 0x07}

	callback := dummyPesCallback()
	pesPkt, err := PesPacket(callback, pkt1, -1, 0, 1, 2)
	if err != nil {
		panic(err)
	}

	assert.Equal(t, false, pesPkt.Ready())
	assert.Equal(t, 4, len(pesPkt.GetPayload()))

	pesPkt.Append(pkt2)
	assert.Equal(t, true, pesPkt.Ready())
	assert.Equal(t, 7, len(pesPkt.GetPayload()))
}

func TestPesPacketPtsDtsHandling(t *testing.T) {
	caseName := []string{"noTimestamp", "ptsOnly", "both"}
	byteSpec := [][]byte{
		{0x00, 0x00, 0x01, 0xea, 0x00, 0x0a, 0x8f, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07},
		{0x00, 0x00, 0x01, 0xea, 0x00, 0x0a, 0x8f, 0x80, 0x05, 0x21, 0x00, 0x2b, 0x4d, 0xbb, 0x01, 0x02},
		{0x00, 0x00, 0x01, 0xea, 0x00, 0x10, 0x8f, 0xc0, 0x0a, 0x31, 0x00, 0x2b, 0x85, 0xfb, 0x11, 0x00, 0x2b, 0x31, 0x9b, 0x01, 0x02, 0x03},
	}
	ptsSpec := []int{-1, 698077, 705277}
	dtsSpec := []int{-1, 698077, 694477}

	for idx := 0; idx < len(caseName); idx++ {
		t.Run(caseName[idx], func(t *testing.T) {
			callback := dummyPesCallback()
			pesPkt, err := PesPacket(callback, byteSpec[idx], -1, 0, 1, 2)
			if err != nil {
				panic(err)
			}

			assert.Equal(t, true, pesPkt.Ready())

			pts, err := pesPkt.GetField("pts")
			if err != nil {
				panic(err)
			}
			assert.Equal(t, ptsSpec[idx], pts)

			dts, err := pesPkt.GetField("dts")
			if err != nil {
				panic(err)
			}
			assert.Equal(t, dtsSpec[idx], dts)
		})
	}
}

func TestZeroLengthPesPacket(t *testing.T) {
	pkt1 := []byte{0x00, 0x00, 0x01, 0xea, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05}
	pkt2 := []byte{0x06, 0x07, 0x08}
	callback := dummyPesCallback()
	pes, err := PesPacket(callback, pkt1, 0, 0, 0, 0)
	if err != nil {
		panic(err)
	}
	pes.Append(pkt2)
	pes.Process()

	size, err := pes.GetField("size")
	if err != nil {
		panic(err)
	}
	assert.Equal(t, 8, size, "PES packet size not match")
}

func TestSCTE35IO(t *testing.T) {
	caseName := []string{
		"SpliceNull",
		"SpliceInsert",
	}
	byteSpecs := [][]byte{
		{0x00, 0xFC, 0x30, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x7A, 0x4F, 0xBF, 0xFF}, // Splice null
		{0x00, 0xfc, 0x30, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0xff, 0xf0, 0x14, 0x05, 0x00, 0x00, 0x00, 0x02, 0x7f,
			0xef, 0xfe, 0x00, 0x2e, 0xb0, 0x30, 0xfe, 0x00, 0x14, 0x99,
			0x70, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0xbb, 0x9e, 0x64, 0x39}, // Splice insert
	}
	manager := dummyManager()

	for idx := range byteSpecs {
		t.Run(caseName[idx], func(t *testing.T) {
			table, err := PsiTable(manager, 0, 35, byteSpecs[idx])
			if err != nil {
				panic(err)
			}
			parseErr := table.Process()
			if parseErr != nil {
				panic(parseErr)
			}

			assert.Equal(t, true, table.Ready(), "SCTE-35 section should be ready for parsing")

			switch idx {
			case 0:
				assert.Equal(t, true, manager.receivedSpliceNull, "Splice null not received")
			case 1:
				assert.Equal(t, []int{3059760}, manager.scte35SplicePTS, "SCTE-35 splice PTS list not match")
			}
		})
	}
}

func TestTsHeaderIO(t *testing.T) {
	headerBytes := []byte{0x47, 0x03, 0x8f, 0x1f}
	rawTsPacket := append(headerBytes, make([]byte, 184)...)

	pkt, err := TsPacket(rawTsPacket)
	if err != nil {
		panic(err)
	}

	tei, fieldErr := pkt.GetField("tei")
	if fieldErr != nil {
		panic(fieldErr)
	}
	assert.Equal(t, 0, tei, "tei not match")

	pusi, fieldErr := pkt.GetField("pusi")
	if fieldErr != nil {
		panic(fieldErr)
	}
	assert.Equal(t, 0, pusi, "pusi not match")

	priority, fieldErr := pkt.GetField("priority")
	if fieldErr != nil {
		panic(fieldErr)
	}
	assert.Equal(t, 0, priority, "priority not match")

	pid, fieldErr := pkt.GetField("pid")
	if fieldErr != nil {
		panic(fieldErr)
	}
	assert.Equal(t, 911, pid, "pid not match")

	tsc, fieldErr := pkt.GetField("tsc")
	if fieldErr != nil {
		panic(fieldErr)
	}
	assert.Equal(t, 0, tsc, "tsc not match")

	afc, fieldErr := pkt.GetField("afc")
	if fieldErr != nil {
		panic(fieldErr)
	}
	assert.Equal(t, 1, afc, "afc not match")

	cc, fieldErr := pkt.GetField("cc")
	if fieldErr != nil {
		panic(fieldErr)
	}
	assert.Equal(t, 15, cc, "cc not match")

	// headerStruct := TsHeader{Tei: false, Pusi: false, Priority: false, Pid: 911, Tsc: 0, Afc: 1, Cc: 15}
}
